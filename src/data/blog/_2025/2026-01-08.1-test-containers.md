---
pubDatetime: 2026-01-08T10:00:00+11:00
title: "Simple: Test Containers (for xUnit v3)"
slug: simple-test-containers
featured: true
draft: false
tags:
  - testing
  - unit-testing
  - integration-testing
  - test-containers
description: âš¡ Making it simple to run integration tests in true integration isolation, quickly! âš¡
---

![Simple Test Containers](@/assets/images/simple-test-containers-header.jpg)
_Image credit: [EthanDavis01](https://www.deviantart.com/ethandavis01/art/High-tech-City-Motherboard1-971894290)_

# ANNOUNCEMENT: Simple: Test Containers is now available!

I'm excited to announce the pre-release of [**Simple: Test Containers**](https://github.com/PureKrome/SimpleTestcontainers.xUnit.v3), a new library designed to decrease the total run time of your integration testing suit. With this tool, you can easily spin up isolated integration-services (aka a database) instances for your tests _that run in parallel_ (via `class` test-collections. aka `CollectionPerClass`) instead of the recommendation (for databases) of using custom collection with the same collection name - which in effect is sequential processing.

## Why use Simple: Test Containers?

It all started with slow database integration tests.

When writing tests that interact with a database, it's crucial to ensure that each test runs in isolation to prevent side effects from affecting the results. Traditional approaches often involve using a shared database instance, which can lead to flaky tests and longer execution times due to the need for setup and teardown between tests / or rollbacking any transaction. These tests are usually also run sequentially to avoid conflicts, which further increases the total run time. It's a single DB instance shared across all tests.

Instead, I wanted to create a solution that allows each test class to have its own isolated database instance, enabling true parallel execution of tests. This approach not only improves test reliability but also significantly reduces the overall execution time of the test suite.

## Initial experimentation

Initially, I thought "lets see if we can have a single docker instance _per test_ - not test _class_ but test _method_. Did it technically work? yep. Did it crush my PC - Yep. When I had 100 tests all running in parallel, each spinning up their own docker container - my PC was toast. So I pivoted to having:

- single docker instance per test assembly.
- single isolated database _per test metthod_. (for the database test containers)

## What about Test Containers (stock code)?

I'm glad you asked! Test Containers is a fantastic library that provides lightweight, throwaway instances of common databases, web browsers, or anything else that can run in a Docker container. It is widely used for integration testing and is a great tool for ensuring that your tests run against real instances of services.

TL:DR; Test Containers are fricking awesome!

But they didn't allow me to run my tests in parallel with isolated services - so I created Simple: Test Containers to fill that gap.

## How does Simple: Test Containers work?

Simple: Test Containers leverages the power of Test Containers to create isolated service (like a database) instances for each test method. Here's a high-level overview of how it works, using a database as an example::

- Each assembly (think: .net project) has it's own docker instance created.
  - It's potentially expensive (memory and bootup-time) to spin up a docker instance, so we only do it once per assembly.
  - E.g. PostgreSQL takes literally 1 second odd to startup. SQL Server takes upwards of 10 seconds to bootup.
- Each method (per class) gets it's own DB tenant.
- Parallization occurs at your parallization setting. By default it's _per class_.

When a test is executed, Simple: Test Containers performs the following steps:

1. **Assembly Setup**: When the test runner starts executing tests in an assembly, Simple: Test Containers checks if a Docker container for the required service (e.g., PostgreSQL, MySQL, etc.) is already running. If not, it spins up a new container instance.
2. **Method Setup**: For each test method, Simple: Test Containers creates a new isolated instance of the service within the Docker container.
3. **Database Initialization**: It initializes the database schema and any required seed data to ensure that the tests have a consistent starting point.
4. **Connection Management**: It provides a connection string or client that points to the newly created database instance, ensuring that the test will interact with this isolated instance.
5. **Test Execution**: The test method runs, interacting with the isolated database instance.
6. **Assembly Teardown**: After all tests have completed, Simple: Test Containers automatically tears down the Docker container, cleaning up resources.

## Getting Started

To start out, please check the GitHub repository for [Simple: Test Containers](https://github.com/PureKrome/SimpleTestcontainers.xUnit.v3)

--

ðŸ¥° I hope this might help anyone looking to speed up their integration tests while maintaining true isolation between tests. If you have any questions, feedback, or suggestions, please feel free to reach out or open an issue on the GitHub repository.
